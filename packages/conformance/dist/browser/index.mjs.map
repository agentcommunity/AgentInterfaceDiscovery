{"version":3,"sources":["../../src/validators.ts"],"sourcesContent":["import { aidManifestSchema, buildManifest, AidGeneratorConfig, AidManifest } from \"@aid/core/browser\";\nimport { z, ZodIssue } from \"zod\";\n\nexport type ValidationResult = {\n  ok: boolean;\n  errors?: { path?: (string | number)[]; message: string }[];\n};\n\n/**\n * Validates a raw JavaScript object against the canonical AID manifest schema.\n *\n * This function performs a strict validation, meaning it will flag any\n * properties that are not explicitly defined in the schema. This is crucial\n * for ensuring that manifests do not contain unknown or potentially\n * dangerous properties.\n *\n * @returns A `ValidationResult` object.\n */\nexport function validateManifest(raw: unknown): ValidationResult {\n  // Use .strict() to ensure no unknown keys are present at the top level.\n  const result = aidManifestSchema.strict().safeParse(raw);\n\n  if (result.success) {\n    // The schema already validates schemaVersion is \"1\" via z.literal(\"1\")\n    return { ok: true };\n  }\n\n  return {\n    ok: false,\n    errors: result.error.issues.map((issue: ZodIssue) => ({\n      path: issue.path,\n      message: issue.message,\n    })),\n  };\n}\n\n/**\n * Validates a DNS TXT record for AID conformance.\n *\n * It checks for:\n * - A valid \"v=aid1\" version identifier.\n * - For single-string TXT records, it parses the key-value pairs.\n * - For multi-string TXT records (an array of strings), it concatenates them\n *   before parsing, as per RFC 1035.\n * - Ensures no duplicate keys are present.\n *\n * @param txt The TXT record content, either as a single string or an array of strings.\n * @returns A `ValidationResult` object.\n */\nexport function validateTxt(txt: string | string[]): ValidationResult {\n  /**\n   * Accept either a bare TXT value (e.g. `v=aid1;proto=mcp`) **or** a full\n   * RFC 1035 zone-file line such as:\n   *   _agent.example.com. 3600 IN TXT \"v=aid1;proto=mcp\"\n   *   _agent.example.com. 3600 IN TXT ( \"v=aid1;proto=mcp\" \";uri=https://â€¦\" )\n   *\n   * If the input does not start with `v=aid1`, we treat it as a zone-file\n   * representation and try to extract the quoted string(s). This makes the\n   * validator more forgiving and allows people to copy-paste the generator's\n   * full output directly.\n   */\n\n  let prepared: string | string[] = txt;\n\n  if (typeof txt === \"string\" && !txt.trimStart().startsWith(\"v=aid1\")) {\n    // Look for one or more quoted segments. If we find them, we use them as\n    // the actual TXT value(s). Otherwise we leave the original string intact\n    // so that the original \"startsWith\" check will still fail and report the\n    // correct error message.\n    const matches = [...txt.matchAll(/\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"/g)].map(\n      (m) => m[1],\n    );\n    if (matches.length === 1) prepared = matches[0];\n    if (matches.length > 1) prepared = matches;\n  }\n\n  const fullTxt = Array.isArray(prepared) ? prepared.join(\"\") : prepared;\n  const errors: { message: string }[] = [];\n  const keys = new Set<string>();\n\n  if (!fullTxt.startsWith(\"v=aid1\")) {\n    errors.push({\n      message: 'TXT record must start with \"v=aid1\".',\n    });\n  }\n\n  const parts = fullTxt.split(\";\");\n  for (const part of parts) {\n    const [key] = part.split(\"=\");\n    if (keys.has(key)) {\n      errors.push({\n        message: `Duplicate key found in TXT record: \"${key}\".`,\n      });\n    }\n    keys.add(key);\n  }\n\n  if (errors.length > 0) {\n    return { ok: false, errors };\n  }\n\n  return { ok: true };\n}\n\n/**\n * Compares a generator configuration with a manifest to ensure they are equivalent.\n *\n * By default, it performs a strict comparison. If `strict` is false, it allows\n * for vendor-specific extensions (extra keys) in the manifest that are not\n * @returns A `ValidationResult` object indicating whether the two are in sync.\n */\nexport function validatePair(\n  cfg: AidGeneratorConfig,\n  manifest: AidManifest,\n  opts: { strict?: boolean } = { strict: true }\n): ValidationResult {\n  const generatedManifest = buildManifest(cfg);\n\n  // For non-strict checks, we can attempt to strip unknown keys from the\n  // provided manifest before comparison, but a simple deep equal is often\n  // sufficient if we assume the generated one is the source of truth.\n  // A proper deep-diff library would be better for rich error reporting.\n  const a = generatedManifest;\n  let b = manifest;\n\n  if (!opts.strict) {\n    // In non-strict mode, we parse the user's manifest to strip any keys\n    // not in the schema. This allows vendors to add their own metadata.\n    const parseResult = aidManifestSchema.safeParse(manifest);\n    if (!parseResult.success) {\n      return {\n        ok: false,\n        errors: [\n          {\n            message: \"Provided manifest is invalid, cannot perform comparison.\",\n            path: [\"manifest\"],\n          },\n          ...parseResult.error.issues.map((issue: ZodIssue) => ({\n            path: issue.path,\n            message: issue.message,\n          })),\n        ],\n      };\n    }\n    b = parseResult.data;\n  }\n\n  // A simple JSON.stringify comparison is a good first pass.\n  if (JSON.stringify(a) === JSON.stringify(b)) {\n    return { ok: true };\n  }\n\n  // TODO: Implement a deep-diff for better error messages.\n  return {\n    ok: false,\n    errors: [\n      {\n        message:\n          \"Manifest does not match the one generated from the provided config.\",\n      },\n    ],\n  };\n} "],"mappings":";AAAA,SAAS,mBAAmB,qBAAsD;AAkB3E,SAAS,iBAAiB,KAAgC;AAE/D,QAAM,SAAS,kBAAkB,OAAO,EAAE,UAAU,GAAG;AAEvD,MAAI,OAAO,SAAS;AAElB,WAAO,EAAE,IAAI,KAAK;AAAA,EACpB;AAEA,SAAO;AAAA,IACL,IAAI;AAAA,IACJ,QAAQ,OAAO,MAAM,OAAO,IAAI,CAAC,WAAqB;AAAA,MACpD,MAAM,MAAM;AAAA,MACZ,SAAS,MAAM;AAAA,IACjB,EAAE;AAAA,EACJ;AACF;AAeO,SAAS,YAAY,KAA0C;AAapE,MAAI,WAA8B;AAElC,MAAI,OAAO,QAAQ,YAAY,CAAC,IAAI,UAAU,EAAE,WAAW,QAAQ,GAAG;AAKpE,UAAM,UAAU,CAAC,GAAG,IAAI,SAAS,6BAA6B,CAAC,EAAE;AAAA,MAC/D,CAAC,MAAM,EAAE,CAAC;AAAA,IACZ;AACA,QAAI,QAAQ,WAAW,EAAG,YAAW,QAAQ,CAAC;AAC9C,QAAI,QAAQ,SAAS,EAAG,YAAW;AAAA,EACrC;AAEA,QAAM,UAAU,MAAM,QAAQ,QAAQ,IAAI,SAAS,KAAK,EAAE,IAAI;AAC9D,QAAM,SAAgC,CAAC;AACvC,QAAM,OAAO,oBAAI,IAAY;AAE7B,MAAI,CAAC,QAAQ,WAAW,QAAQ,GAAG;AACjC,WAAO,KAAK;AAAA,MACV,SAAS;AAAA,IACX,CAAC;AAAA,EACH;AAEA,QAAM,QAAQ,QAAQ,MAAM,GAAG;AAC/B,aAAW,QAAQ,OAAO;AACxB,UAAM,CAAC,GAAG,IAAI,KAAK,MAAM,GAAG;AAC5B,QAAI,KAAK,IAAI,GAAG,GAAG;AACjB,aAAO,KAAK;AAAA,QACV,SAAS,uCAAuC,GAAG;AAAA,MACrD,CAAC;AAAA,IACH;AACA,SAAK,IAAI,GAAG;AAAA,EACd;AAEA,MAAI,OAAO,SAAS,GAAG;AACrB,WAAO,EAAE,IAAI,OAAO,OAAO;AAAA,EAC7B;AAEA,SAAO,EAAE,IAAI,KAAK;AACpB;AASO,SAAS,aACd,KACA,UACA,OAA6B,EAAE,QAAQ,KAAK,GAC1B;AAClB,QAAM,oBAAoB,cAAc,GAAG;AAM3C,QAAM,IAAI;AACV,MAAI,IAAI;AAER,MAAI,CAAC,KAAK,QAAQ;AAGhB,UAAM,cAAc,kBAAkB,UAAU,QAAQ;AACxD,QAAI,CAAC,YAAY,SAAS;AACxB,aAAO;AAAA,QACL,IAAI;AAAA,QACJ,QAAQ;AAAA,UACN;AAAA,YACE,SAAS;AAAA,YACT,MAAM,CAAC,UAAU;AAAA,UACnB;AAAA,UACA,GAAG,YAAY,MAAM,OAAO,IAAI,CAAC,WAAqB;AAAA,YACpD,MAAM,MAAM;AAAA,YACZ,SAAS,MAAM;AAAA,UACjB,EAAE;AAAA,QACJ;AAAA,MACF;AAAA,IACF;AACA,QAAI,YAAY;AAAA,EAClB;AAGA,MAAI,KAAK,UAAU,CAAC,MAAM,KAAK,UAAU,CAAC,GAAG;AAC3C,WAAO,EAAE,IAAI,KAAK;AAAA,EACpB;AAGA,SAAO;AAAA,IACL,IAAI;AAAA,IACJ,QAAQ;AAAA,MACN;AAAA,QACE,SACE;AAAA,MACJ;AAAA,IACF;AAAA,EACF;AACF;","names":[]}